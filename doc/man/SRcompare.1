.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SRCOMPARE 1"
.TH SRCOMPARE 1 "2005-01-13" "perl v5.8.1" "QTL Cartographer 1.17 Perl Script"
.SH "NAME"
SRcompare.pl \- Compare a pair of SRmapqtl outut files to see how many cofactors were gained or lost
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  SRcompare.pl [-f SRmapqtl.old] [-h] < SRmapqtl.new > output
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSRcompare.pl\fR reads from the standard input and writes to the standard
output. It is meant to compare the set of cofactors in two \fBSRmapqtl\fR
output files.   It will print out the number of cofactors that are
the same, lost or gained in the two files.  
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-f\fR" 4
.IX Item "-f"
This option requires an input filename that must exist.  It allows the user to specify 
the old \fISRmapqtl.out\fR file for processing.   If it is not given, then the script dies.
.IP "\fB\-h\fR" 4
.IX Item "-h"
requires no operand.  If used, it prints a usage message and exits.
.SH "INPUT FILES"
.IX Header "INPUT FILES"
The input files should be of the same format as the output of \fBSRmapqtl\fR.   
You should have only one set of such results in a file to be processed by
\&\fBSRcompare.pl\fR.   These results are created by \fBEqtl\fR as well as \fBSRmapqtl\fR.  
.SH "OUTPUT"
.IX Header "OUTPUT"
At this time the output will be a single line telling how many cofactors 
were lost, gained or remained, between the two files.  For example:
.PP
.Vb 1
\&  10 are the same, 2 were lost and 0 were gained.
.Ve
.PP
Ideally, you would like to see 0 lost and 0 gained.  
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Suppose we have a map in \fIqtlcart.map\fR and a data file in \fIqtlcart.cro\fR, and
that there is no resource file in the current directory.   For this example, 
assume that there are only two marker genotypes (that is a backcross or recombinant
inbred line) and one trait.   The following series of commands can be used to 
compare the cofactors chosen from interval mapping with those from composite interval
mapping:
.PP
.Vb 9
\&    % Qstats -X qtlcart
\&        % Zmapqtl -M 3 -A
\&        % Eqtl -S 12.0 -H 10 -I Z -A
\&        % mv qtlcart.z qtlcart.z.1
\&        % Zmapqtl -M 8 -A
\&        % mv qtlcart.eqt qtlcart.eqt.1
\&        % mv qtlcart.sr qtlcart.sr.1
\&        % Eqtl -S 12.0 -H 10 -I Z -A 
\&        % SRcompare.pl -f qtlcart.sr.1 < qtlcart.sr
.Ve
.PP
In the above,   \fBQstats\fR is run to set the filename stem.  Next, \fBZmapqtl\fR does an
interval mapping analysis and \fBEqtl\fR picks a set of markers closest to the peaks
from  interval mapping:  These peaks are only used if they have likelihood ratios greater
than 12.0.  Next, the interval mapping results are moved to an new file and 
composite interval mapping is run using the cofactors identified via interval mapping.
The previous output files of \fBEqtl\fR (\fIqtlcart.eqt\fR and \fIqtlcart.sr\fR) are renamed and 
new files are generated from the composite interval mapping results.   Then, \fBSRcompare.pl\fR 
is used to compare the two sets of results, those from interval mapping (\fIqtlcart.sr.1\fR)
and those from composite interval mapping (\fIqtlcart.sr\fR).   
.PP
This type of analysis can be iterated until a stable set of cofactors are identified.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fB\f(BIEqtl\fB\|(1)\fR, \fB\f(BIQstats\fB\|(1)\fR, \fB\f(BISRmapqtl\fB\|(1)\fR, \fB\f(BIZmapqtl\fB\|(1)\fR 
.SH "AUTHORS"
.IX Header "AUTHORS"
In general, it is best to contact us via email (basten@statgen.ncsu.edu).
.PP
.Vb 4
\&        Christopher J. Basten, B. S. Weir and Z.-B. Zeng
\&        Department of Statistics, North Carolina State University
\&        Raleigh, NC 27695-7566, USA
\&        Phone: (919)515-1934
.Ve
